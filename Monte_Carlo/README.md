# Зависимость намагниченности от температуры в модели Изинга на квадратной решетке. Метод Монте Карло, алгоритм метрополиса.
## Модель изинга
В статистическом механика , двумерная квадратная решетка модель Изинга представляет собой простую решеточную модель взаимодействующих магнитных спинов.
Простыми словами это квадратная решетка (сетка) со спинами, расположенными в случайном порядке. 
## Метод Монте-Карло
Процесс описывается математической моделью с использованием генератора случайных величин, модель многократно обсчитывается, 
на основе полученных данных вычисляются вероятностные характеристики рассматриваемого процесса. Например, чтобы узнать методом Монте-Карло, 
какое в среднем будет расстояние между двумя случайными точками в круге, нужно взять координаты большого числа случайных пар точек в границах 
заданной окружности, для каждой пары вычислить расстояние, а потом для них посчитать среднее арифметическое.
</br>
Всего возможно 2N состояний и при достаточно большом числе спинов N трудно получить численные результаты. 
Например при N=10 получим 210 состояний, которые напрямую смоделировать не так просто, поэтому для моделирования используется статистический подход.
</br>
В этом подходе система рассматривается в состоянии термодинамического равновесия при определенной температуре T. 
В ходе обмена энергией с окружающей средой, энергия будет изменяться около равновесного состояния, а средняя энергия одной частицы пропорциональна T. Реализация постоянного случайного изменения вокруг состояния равновесия использует метод Монте-Карло и моделирование можно разделить на этапы:
</br>
* Разыгрывать состояния αi системы (например, случайным образом) при фиксированном T;
* Считать для этих состояний термодинамические характеристики вблизи равновесия (энергию E, намагниченность M);
* Усреднять полученные значения
## Алгоритм метрополиса
В задачах статистической механики выражения «метод Монте-Карло» и «метод выборки Метрополиса» — почти синонимы. 
Приведем наиболее общую форму алгоритма Метрополиса на примере системы спинов или частиц:
* Формируем начальную конфигурацию.
* Производим случайное пробное изменение в начальной конфигурации. Например, выбираем случайным образом какой-нибудь спин и пробуем его опрокинуть. Или выбираем случайную частицу и пробуем переместить ее на случайное расстояние.
* Вычисляем ∆Е, то есть изменение энергии системы, обусловленное произведенным пробным изменением конфигурации.
* Если ∆Е меньше или равно нулю, то принимаем новую конфигурацию и переходим к шагу 8.
* Если ∆Е положительно, вычисляем «вероятность перехода»:</br>
![image](https://user-images.githubusercontent.com/66952748/158302610-991ff0b4-8115-41b2-9a6e-740cb16f07b5.png)
* Генерируем случайное число rnd в интервале (0, 1)
* Если rnd≤W, то новую конфигурацию принимаем, в противном случае сохраняем предыдущую конфигурацию.
* Определяем значения требуемых физических величин.
* Повторяем шаги 2–8 для получения достаточного числа конфигураций или «испытаний».
* Вычисляем средние по конфигурациям, которые статистически независимы друг от друга.


```python
from matplotlib import pyplot as plt
import numpy as np 

t=0
J=1
n=10 # решетка 10*10
A = np.zeros((n,n),dtype=int)
M = []
f = []
for T in np.linspace(0.1,5,50): # изменение температуры от 0 до 5
    beta = 1/T
     #Формируем начальную конфигурацию.
    A[0::2,::]= 1 #np.array([1 if x>0.5 else -1 for x in np.random.rand(50)]).reshape((n//2,n))
    A[::,0::2]= 1 #np.array([1 if x>0.5 else -1 for x in np.random.rand(50)]).reshape((n,n//2))

    M.append(0)
    f.append(0)
    
    for it in range (1,100000):         #количество проверки случайных ячеек
        i=1
        j=1
        while (((i%2) != 0) or ((j%2) != 0)):         #задаем случайную ячейку
            i=np.random.randint(n)
            j=np.random.randint(n)
        E1 = 0                         
        
        #print(i,j, "A = ", A[i,j])
        #Вычисляем ∆Е, то есть изменение энергии системы, обусловленное произведенным пробным изменением конфигурации.

        if (j-1)>=0 :                   #левый 
            E1+=J*(A[i,j]*A[i,j-1])
        if (i+1)<=n-1 :                 #нижний
            E1+=J*(A[i,j]*A[i+1,j])
        if (j+1)<=n-1 :                 #верхний
            E1+=J*(A[i,j]*A[i,j+1])
        if (i-1)>=0 :                   #правый
            E1+=J*(A[i,j]*A[i-1,j])

        dE = 2*E1                       # так как изменения попарны

        # Если ∆Е меньше или равно нулю, то принимаем новую конфигурацию (в нашем случае переворачиваем спин)
        if dE < 0:
            A[i,j] = -1*A[i,j]
        
        # алгоритм Метрополиса
        # Если ∆Е положительно, вычисляем «вероятность перехода»:
        elif np.exp(-1*dE*beta)>np.random.rand():                       # Генерируем случайное число rnd в интервале (0, 1)
            A[i,j] *= -1*A[i,j]                                         # Если rnd≤W, то новую конфигурацию принимаем
        
        if(it>90000):
            M[t] += np.sum(A)/75                                        #намагниченность как сумма спинов/на количество ячеек

    # Вычисляем средние по конфигурациям, которые статистически независимы друг от друга.
    
    M[t] = M[t]/10000                  #намагниченность средняя за последние 10000 шагов
    f[t] = T
    t=t+1

plt.plot(f,M)
plt.title('Зависимость намагниченности от температуры')
plt.xlabel('T')
plt.ylabel('M')
plt.show()
```
## Результаты:
![image](https://user-images.githubusercontent.com/66952748/158302708-1852d223-e566-42e3-ba9a-333c458f8c2a.png)
