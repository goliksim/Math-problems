# Генератор псевдослучайных чисел (ГПСЧ) методом перемешивания.
В методе перемешивания используются операции циклического сдвига содержимого ячейки влево и вправо.
## Суть метода
 
Пусть в ячейке хранится начальное число R0. 
Циклически сдвигая содержимое ячейки влево на 1/4 длины ячейки, получаем новое число R0*. 
Точно так же, циклически сдвигая содержимое ячейки R0 вправо на 1/4 длины ячейки, получаем второе число R0**. 
Сумма чисел R0* и R0** дает новое случайное число R1. Далее R1 заносится в R0, и вся последовательность операций повторяется
</br></br>
![image](https://user-images.githubusercontent.com/66952748/158296228-4e52f8b8-00fe-4c5d-91ef-420397f24eec.png)
</br></br>
## Учет лишних разрядов
Число, полученное в результате суммирования R0* и R0**, может не уместиться полностью в ячейке R1. 
В этом случае от полученного числа должны быть отброшены лишние разряды. 
Поясним это для рис. 22.8, где все ячейки представлены восемью двоичными разрядами. 
Пусть R0* = 100100012 = 14510, R0** = 101000012 = 16110, тогда R0* + R0** = 1001100102 = 30610. 
Как видим, число 306 занимает 9 разрядов (в двоичной системе счисления), а ячейка R1 (как и R0) может вместить в себя максимум 8 разрядов. 
Поэтому перед занесением значения в R1 необходимо убрать один «лишний», крайний левый бит из числа 306, в результате чего в R1 пойдет уже не 306,
а 001100102 = 5010. В таких языках, как Паскаль, «урезание» лишних битов при переполнении ячейки производится автоматически 
в соответствии с заданным типом переменной.

```python
# очистка консоли от ненужной информации библиотек
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

#количество точек выборки
Iterations = 1000

#функция генерации последовательности
def mixing(number, CountOfNumbers):
    den = 2
    RandomsArray = []
    while len(RandomsArray) != CountOfNumbers:
        R_start = str(bin(number))[2:]              # убираем 0b
        a = int(R_start[+den:] + R_start[:+den], base = 2)
        b = int(R_start[-den:] + R_start[:-den], base = 2)
        number = a + b
        RandomsArray.append(float("0." + str(number)[1:]))

    return RandomsArray

# функция вывода визуальной информации
def print_bars(vector, name):
    fig = plt.figure(figsize=(10,4))
    plt.subplot(1,2,1)
    plt.scatter(range(Iterations),vector,s=10)
    plt.title(name)
    plt.ylabel("Значение числа")
```
# Моя задача (Гипотеза Хи-квадрат)
Задачей моей же работы было достижение подтверждения гипотезы хи-квадрат о равномерном распределении последовательности при использовании данного генератора.
Критерий Пирсона, или критерий χ2(Хи-квадрат) - применяют для проверки гипотезы о соответствии эмпирического распределения предполагаемому теоретическому 
распределению F(x) при большом объеме выборки (n ≥ 100).
Использование критерия χ2 предусматривает разбиение размаха варьирования выборки на интервалы и определения числа наблюдений (частоты) для каждого из интервалов. 
В моем случае проверка идет на равномерное распределение последовательности генерируемых чисел методом перемешивания. Числа могут принимать значения от 0 до 1.
В программе я использую разбиение интервала на отрезки ширины 0.1, их частоту и считаем.
### Статистика критерия
![image](https://user-images.githubusercontent.com/66952748/158297998-dbeac7fb-26f1-45b9-b95c-8a7c1d341dc5.png)
### Правило критерия
Если полученная статистика превосходит квантиль закона распределения χ2 заданного уровня значимости α с (k - 1) или с (k -  p - 1) степенями свободы, 
где k - число наблюдений или число интервалов (для случая интервального вариационного ряда), а p — число оцениваемых параметров закона распределения, 
то гипотеза H0 отвергается. В противном случае гипотеза принимается на заданном уровне значимости α.
</br>
В моем случае количество степеней свободы k=10-1=9. 
```python

    sorted_vector = sorted(vector)
    plt.subplot(1,2,2)
    sns.distplot(sorted_vector)
    
    plt.title(name)
    plt.xlabel("Интервал разбиения")
    plt.ylabel("Вероятность попадания в интервал")
    plt.tight_layout()
    plt.show()

# проверка критерия согласия Пирсона 
def xi_2_proof(vector, bins=10):

    xi_2 = 0
    for i in np.linspace(0.1, 1, bins):
        xi_2 += (sum((vector > i-0.1) & (vector < i)) - Iterations/bins)**2 / (Iterations/bins)
    

    xi_2_5 = 16.9  # для 10-1 = 9 степень свободы
    xi_2_95 = 3.33

    if (xi_2 > xi_2_95 and xi_2 < xi_2_5):
        print("H0") 
    else:
        print("H1") 
    return xi_2
```
Основная функция скрипта
```python
if __name__ == "__main__":
    
    #Iterations= 1000 # 7553 - начальное число (сид генерации), подобрано итерационным методом   
    
    vec_mix_method = np.array(mixing(7001, Iterations))
        
    vec_mix_method = (vec_mix_method - np.min(vec_mix_method))/(np.max(vec_mix_method)-np.min(vec_mix_method))  
    # нормализовал выборку, понизив статистику хи-квадрат, 
        
    bins = 10   # количество разбиений от 0 до 1
    xi_2 = xi_2_proof(vec_mix_method, bins)
        
    print(f"Статистика хи-квадрат: {xi_2:.2f}")
    print("Количество разных чисел:",len(set(vec_mix_method)))   # все числа разные, значит период как минимум больше 1000
    print_bars(vec_mix_method, "Метод Перемешивания")
        
```
Гипетеза H0 принимается на уровне значимости 0.95.
</br></br>
![image](https://user-images.githubusercontent.com/66952748/158296199-499ab7be-da12-4622-8f88-01d401bbe43a.png)
### Таблица согласованности: 
![image](https://user-images.githubusercontent.com/66952748/158299710-b6a089f6-f244-42e3-a3ba-6d2a083f20f5.png)
</br>
Спасибо за внимание!
